---
title: "Lab 8: Data Frame Functions"
author: "Kallan Torell"
format: html
editor: source
embed-resources: true
execute: 
  code-tools: true
  eval: true
  echo: true
  error: false
  warning: false
  
---

```{r}
#| label: setup

library(tidyverse)
library(palmerpenguins)

palmerpenguins::penguins
```

## Function to Spath_to_file()## Function to Standardize Variables in a Data Frame

Last week, you wrote a `rescale_01()` function which would rescale the values of
a numeric variable to be between 0 and 1. This function worked on vectors, so 
to use it we needed to pair the function with `mutate()` if we wanted to make
changes to the data. This week, we are going to use this function as a helper
function for a larger `rescale_column()` function that will rescale variables in
a given data frame. 

**Question 1: Create a `rescale_column()` function that accepts two arguments:**

- **a data frame**
- **one or more variable names to rescale**


**The body of the function should call the original `rescale_01()` function you wrote previously and return the original data frame with those columns replaced by their rescaled versions.**

::: callout-important
Your function call must look like one of these two options:

```{r}
#| eval: false

# Tidy (unquoted) variable names
rescale_column(df, c(height, weight))

# Quoted variable names
rescale_column(df, c("height", "weight"))
```

To achieve this, you function must use one of the `rlang` (tidy evaluation) options from class.
:::

```{r}
#| label: df-rescale-function
#| 
rescale_01 <- function(x) {
  r <- range(x, na.rm = TRUE)
  (x - r[1]) / (r[2] - r[1])
}
#https://www.rdocumentation.org/packages/scales/versions/1.4.0/topics/rescale
#basic documentation help for me, added the source
rescale_column <- function(df, cols) {
  df |>
    dplyr::mutate(
      dplyr::across({{ cols }}, rescale_01)
    )
}

```

**Test Your Function:** Use your `rescale_column()` function to rescale the 
`bill_length_mm`, `bill_depth_mm`, `flipper_length_mm`, and `body_mass_g` 
columns of the `penguins` dataset. *Note:* You may need to change the function
inputs if you chose to use a character vector.

```{r}
#| label: rescale-column-test

rescale_column(penguins, 
               cols = c(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)
               )


```

## Function to Create a Table

We've started to get more sophisticated with making tables, so let's see if 
we can take these skills and create a function that outputs a pivoted table of 
counts. 

**Question 2: Write a `pivot_table()` function which takes in two categorical variables, 
counts the number of observations in each group, and outputs a table of counts
that has been pivoted wider.** 

**Your function should accept three arguments:**

- **a data frame**
- **a row variable (categorical variable to appear in the rows)**
- **a column variable (categorical variable to appear in the columns)**

**Your function should:**

- **count the number of observations for each combination of the two variables**
- **pivot the results wider so that the row variable forms rows and the column variable forms columns**
- **replace any missing counts (`NA`) with 0**
- **add row and column totals using `janitor::adorn_totals()`**

::: callout-important
Your function call must look like one of these two options:

```{r}
#| eval: false

# Tidy (unquoted) variable names
pivot_table(df, c(species, island))

# Quoted variable names
pivot_table(df, c("species", "island"))
```

To achieve this, you function must use one of the `rlang` (tidy evaluation) options from class.
:::

```{r}
#| label: pivot-table-function
library(janitor)

pivot_table <- function(df, row_var, col_var) {
  df |>
    dplyr::count({{ row_var }}, {{ col_var }}) |>   # count combinations
    tidyr::pivot_wider(
      names_from = {{ col_var }},
      values_from = n,
      values_fill = 0
    ) |>
    janitor::adorn_totals(where = c("row", "col"))
}
#https://www.rdocumentation.org/packages/janitor/versions/2.2.1
#needed some more assistance past the notes, I missed class
```

### Test Your Function

Use your `pivot_table()` function to display a table of counts for the `species`
and `sex` of the penguins from the `penguins` dataset. *Note:* You may need to
modify the names of the arguments! 

```{r}
#| label: pivot-table-test

pivot_table(penguins, row = sex, col = species)
```


## Function to Create a Plot

In the chapter you saw a few different types of plotting functions---creating 
histograms with a specified `binwidth`, checking the linearity of a scatterplot,
using hexagons to avoid over plotting in a scatterplot, and sorting bars from 
least to greatest in a barplot. 

For this section, you are going to use these functions as inspiration to write 
your own plotting function. 

**Question 3: Your plotting function must meet the following criteria:**

- **a data frame must be the first argument**
- **two additional arguments for variables (can be numeric or categorical)**
- **the plot must map one of the variables to color (or fill)**
- **axis labels and the plot title should be descriptive (e.g., use `labs()` to replace raw variable names with human-readable labels)**
- **return a ggplot object**

You may choose the plot type (e.g., scatterplot, barplot, boxplot), as long as
it meets the criteria above. You can also choose whether your function accepts
quoted or unquoted variable names, but you must use one of the 
`rlang` (tidy evaluation) options from class.

::: {.callout-important}
# Double Encoding

If you choose to assign a `color` or `fill` aesthetic to a variable that has 
already been mapped to another aesthetic (e.g., `x`, `y`), then you are 
expected to remove the legend from your plot. Technically, your legend has 
redundant information that we don't want to include in the plot!
:::

```{r}
#| label: plot-function
#| 
boxplot_plot <- function(df, x, y, fill_var, title = NULL) {
  if (missing(fill_var)) {
    plot_q3 <- df |>
      ggplot2::ggplot(ggplot2::aes(x = {{ x }}, y = {{ y }}, fill = {{ x }})) +
      ggplot2::geom_boxplot() +
      ggplot2::theme_light() +
      ggplot2::guides(fill = "none")
  } else {
    plot_q3 <- df |>
      ggplot2::ggplot(ggplot2::aes(x = {{ x }}, y = {{ y }}, fill = {{ fill_var }})) +
      ggplot2::geom_boxplot() +
      ggplot2::theme_light()
  }

  if (!is.null(title)) plot_q3 <- plot_q3 + ggplot2::labs(title = title)
  plot_q3
}

#https://ggplot2.tidyverse.org/reference/ggtheme.html
#I wanted to research alternate themes and see if there were other packages i could download for ggthemes

```

### Test Your Function

Test your function using variables from the `penguins` dataset. 

```{r}
#| label: plot-function-test1
#| 
boxplot_plot(penguins, species, body_mass_g,
             title = "Body Mass by Species")

```
```{r}
#| label: plot-function-test2
#| 
boxplot_plot(penguins, species, body_mass_g, fill_var = sex,
             title = "Body Mass by Species and Sex")

```


## Function to Style a Plot

For this final section, I want you to write a wrapper function that can 
style any `ggplot` object you create. 

**Question 4: Write a `style_plot()` function which accepts four arguments:**

- **a ggplot object**
- **a theme function (e.g., `theme_bw()`)**
    + **the function should set a default theme (e.g., `theme_minimal()`)**
- **a vector of colors (e.g., `RColorBrewer::brewer.pal(8, "Accent")`)**
    + **the function should set a default color palette**
- **a string indicating which aesthetic the colors should be applied to ("fill" or "color")**

**Your function should:**

- **Apply the given (or default) theme to the plot**
- **Apply the colors to the specified aesthetic (fill or color)**
- **Return the styled plot**

```{r}
#| label: styled-plot
style_plot <- function(plot_q4,
                       theme_fn   = ggplot2::theme_light,
                       palette_fn = function(n) viridisLite::mako(n),
                       aesthetic  = c("fill", "color"),
                       n_colors   = 8) {
  aesthetic  <- match.arg(aesthetic)
  theme_plot <- if (is.function(theme_fn)) theme_fn() else theme_fn
  colors     <- palette_fn(n_colors)

  scale_plot <- if (aesthetic == "fill") {
    ggplot2::scale_fill_manual(values = colors)
  } else {
    ggplot2::scale_color_manual(values = colors)
  }
  plot_q4 + theme_plot + scale_plot
}



```

### Test Your Function

Carry out the two tests below for your `style_plot()` function. *Note:* You may
need to modify the names of the arguments!

**Test 1:** My plot

I've created a barplot that is stored as `my_plot`. Test your function using
this plot. 

```{r}
#| label: style-plot-test-1
library(RColorBrewer)

penguin_counts <- penguins |>
  count(species, sex)

ggplot(penguin_counts, aes(x = species, y = n, fill = sex)) +
  geom_col(position = "dodge") +
  geom_text(
    aes(label = n),
    position = position_dodge(width = 0.85),
    vjust = -0.3,
    size = 3
  ) +
  labs(
    title = "Penguin counts by species and sex",
    x = "Species",
    y = "Count"
  )
#revised: added gemo_text and geom_col to add to aesthetic of plot
```

**Test 2:** Your plot

Copy the code from your test of your plotting function (@plot-function-test) 
and use your `style_plot()` function to style the plot! Your test **should not**
save any objects!

```{r}
#| label: style-plot-test-2
boxplot_plot(penguins, species, body_mass_g, fill_var = sex, 
             title = "Body Mass by Species and Sex") |>
  style_plot(theme_fn = theme_light,
             palette_fn = function(n) viridisLite::mako(n),
             aesthetic = "fill")



```


```{r}
#| label: style-plot-test-2 Revised
penguins_releveled <- penguins |>
  dplyr::mutate(sex = forcats::fct_relevel(sex, "female", "male"))

boxplot_plot(penguins_releveled, species, body_mass_g, fill_var = sex, 
             title = "Body Mass by Species and Sex") |>
  style_plot(theme_fn = theme_light,
             palette_fn = function(n) viridisLite::mako(n),
             aesthetic = "fill")
#Revision: through independent research and instructor noting my lack of legend ordering, I revised the above plot i made and created a releveled version using https://www.rdocumentation.org/packages/forcats/versions/1.0.1/topics/fct_relevel
# uses forcats package and manually reorders the levels of a factor variable
# releveling sex makes the legend order more intentional
```

